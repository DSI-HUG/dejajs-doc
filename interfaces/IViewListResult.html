<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>@deja-js/component documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">@deja-js/component documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>
            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>IViewListResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/common/core/item-list/item-list.service.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Structure de retour de getViewList. </p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#depthMax">depthMax</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#visibleList">visibleList</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="depthMax"></a>
                                        <span class="name"><b>depthMax</b><a href="#depthMax"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>depthMax:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="visibleList"></a>
                                        <span class="name"><b>visibleList</b><a href="#visibleList"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>visibleList:     <code><a href="../interfaces/IItemBase.html" target="_self" >IItemBase[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/IItemBase.html" target="_self" >IItemBase[]</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { BehaviorSubject, concat as observableConcat, from as observableFrom, iif as observableIif, Observable, of as observableOf, Subscriber } from &#x27;rxjs&#x27;;
import { filter, map, reduce, switchMap, tap } from &#x27;rxjs/operators&#x27;;
import { Diacritics } from &#x27;../diacritics/diacritics&#x27;;
import { IGroupInfo } from &#x27;../grouping/group-infos&#x27;;
import { GroupingService } from &#x27;../grouping/grouping.service&#x27;;
import { ISortInfos } from &#x27;../sorting/sort-infos.model&#x27;;
import { SortingService } from &#x27;../sorting/sorting.service&#x27;;
import { IItemBase } from &#x27;./item-base&#x27;;
import { IItemTree } from &#x27;./item-tree&#x27;;

/** Service de gestion des listes (deja-treelist, deja-select et deja-grid).
 * Ce service permet la gestion du viewport et la gestion des caches des listes.
 * Il peut-être surchargé pour faire du lazy loading ou du paging.
 */
export class ItemListService {
    public static defaultChildrenField &#x3D; &#x27;items&#x27;;
    public static defaultTextField &#x3D; &#x27;displayName&#x27;;
    public static defaultValueField &#x3D; &#x27;value&#x27;;

    // Waiter
    private _waiter$ &#x3D; new BehaviorSubject&lt;boolean&gt;(false);

    // Working item array (can be recursive)
    private _items: IItemBase[];

    // Cache for lists (flat lists only, not recursive)
    private _cache &#x3D; {} as {
        rowsCount?: number;
        depthMax?: number;
        groupedList?: IItemTree[];
        flatList?: IItemBase[];
        visibleList?: IItemBase[];
    };

    // Selected items cache
    private selectedList: IItemBase[];
    private _hideSelected: boolean;

    // Cache for last query. Flat list will be regenerated only if the query change
    private _lastQuery: RegExp | string;
    private internalQuery: RegExp;

    // Sorting
    private _sortingService: SortingService;

    // grouping
    private _groupInfos: IGroupInfo[];
    private _groupingService: GroupingService;

    // Cache for drag and drop (flat list modified by the current drag).
    private _ddList: IItemBase[];
    private _ddCurrentIndex: number;
    private _ddChildCount: number;

    private _childrenField &#x3D; ItemListService.defaultChildrenField;

    // Cnacelable pre events
    private loadingItems$: (query: string | RegExp, selectedItems: IItemBase[]) &#x3D;&gt; Observable&lt;IItemBase[]&gt;;
    private selectingItem$: (item: IItemBase) &#x3D;&gt; Promise&lt;IItemBase&gt; | Observable&lt;IItemBase&gt;;
    private unselectingItem$: (item: IItemBase) &#x3D;&gt; Promise&lt;IItemBase&gt; | Observable&lt;IItemBase&gt;;
    private expandingItem$: (item: IItemTree) &#x3D;&gt; Promise&lt;IItemTree&gt; | Observable&lt;IItemTree&gt;;
    private collapsingItem$: (item: IItemTree) &#x3D;&gt; Promise&lt;IItemTree&gt; | Observable&lt;IItemTree&gt;;

    // champs à utiliser comme valeur de comparaison
    private _valueField: string;

    /** Evalue la valeur à comparer pour l&#x27;élément spécifié.
     * @param value  Model à évaluer.
     * @param valueField (optional) Champs à traiter comme valeur.
     * @return Valeur à comparer pour le modèle spécifié.
     */
    public static getItemValue(item: any, valueField?: string) {
        // tslint:disable-next-line:triple-equals
        const isDefined &#x3D; (value: any) &#x3D;&gt; value !&#x3D; undefined;

        if (valueField) {
            const fields &#x3D; valueField.split(&#x27;.&#x27;);
            let model &#x3D; item.model &amp;&amp; item.model[fields[0]] !&#x3D;&#x3D; undefined ? item.model : item;
            fields.forEach((fieldName) &#x3D;&gt; {
                model &#x3D; model &amp;&amp; model[fieldName];
            });
            if (isDefined(model)) {
                return typeof model &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? model() : model;
            }
        }

        return isDefined(item.value) ? item.value : (isDefined(item.model) ? item.model : item);
    }

    /** Evalue le texte à afficher pour l&#x27;élément spécifié.
     * @param value  Model à évaluer.
     * @param textField (optional) Champs à traiter comme source du texte.
     * @return Texte à afficher pour le modèle spécifié.
     */
    public static getItemText(value: any, textField?: string) {
        if (value) {
            if (textField) {
                const fields &#x3D; textField.split(&#x27;.&#x27;);
                let model &#x3D; value.model &amp;&amp; value.model[fields[0]] !&#x3D;&#x3D; undefined ? value.model : value;
                fields.forEach((fieldName) &#x3D;&gt; {
                    model &#x3D; model &amp;&amp; model[fieldName];
                });
                if (model !&#x3D;&#x3D; undefined) {
                    return typeof model &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? model() : model;
                }
                return &#x27;&#x27;;
            }

            if (value.displayName) {
                return typeof value.displayName &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? value.displayName : value.displayName();
            } else if (typeof value.toString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
                return value.toString();
            }
        }
        return &#x27;&#x27;;
    }

    public get lastQuery() {
        return this._lastQuery;
    }

    /**
     * Set a observable called before the list will be displayed
     */
    public setLoadingItems(fn: (query: string | RegExp, selectedItems: IItemBase[]) &#x3D;&gt; Observable&lt;IItemBase[]&gt;) {
        this.loadingItems$ &#x3D; fn;
    }

    /**
     * Set a promise or an observable called before an item selection
     */
    public setSelectingItem(fn: (item: IItemBase) &#x3D;&gt; Promise&lt;IItemBase&gt; | Observable&lt;IItemBase&gt;) {
        this.selectingItem$ &#x3D; fn;
    }

    /**
     * Set a promise or an observable called before an item deselection
     */
    public setUnselectingItem(fn: (item: IItemBase) &#x3D;&gt; Promise&lt;IItemBase&gt; | Observable&lt;IItemBase&gt;) {
        this.unselectingItem$ &#x3D; fn;
    }

    /**
     * Set a promise or an observable called before an item expand
     */
    public setExpandingItem(fn: (item: IItemTree) &#x3D;&gt; Promise&lt;IItemTree&gt; | Observable&lt;IItemTree&gt;) {
        this.expandingItem$ &#x3D; fn;
    }

    /**
     * Set a promise or an observable called before an item collapse
     */
    public setCollapsingItem(fn: (item: IItemTree) &#x3D;&gt; Promise&lt;IItemTree&gt; | Observable&lt;IItemTree&gt;) {
        this.collapsingItem$ &#x3D; fn;
    }

    /**
     * Permet de controler l&#x27;affichage du waiter
     * @return un sujet contenant la valeur du waiter
     */
    public get waiter$(): BehaviorSubject&lt;boolean&gt; {
        return this._waiter$;
    }

    /** Définit le champs utilisé comme collection pour les enfants d&#x27;un parent.
     * @param value Nom du champ à utiliser comme collection d&#x27;enfants
     */
    public set childrenField(value: string) {
        this._childrenField &#x3D; value || ItemListService.defaultChildrenField;
        this.invalidateCache();
    }

    /** Renvoie le champs utilisé comme collection pour les enfants d&#x27;un parent
     * @return value Nom du champ à utilisé comme collection d&#x27;enfants.
     */
    public get childrenField() {
        return this._childrenField;
    }

    /** Définit une valeur indiquant si les éléments selectionés doivent être masqué. Ce flag est principalement utilisé dans le cas d&#x27;un multi-select
     * @param value True si les éléments selectionés doivent être masqués
     */
    public set hideSelected(value: boolean) {
        this._hideSelected &#x3D; value;
    }

    /** Renvoie une valeur indiquant si les éléments selectionés doivent être masqué.
     * @return value True si les éléments selectionés sont masqués
     */
    public get hideSelected() {
        return this._hideSelected;
    }

    /** Définit le champs à utiliser comme valeur de comparaison */
    public set valueField(valueField: string) {
        this._valueField &#x3D; valueField;
    }

    /** Renvoie le champs à utiliser comme valeur de comparaison */
    public get valueField() {
        return this._valueField;
    }

    public get hasCache() {
        return this._cache &amp;&amp; !!this._cache.visibleList;
    }

    private set items(items: IItemBase[]) {
        this._items &#x3D; items;
        this.invalidateCache();
    }

    private get items() {
        return this._items;
    }

    /** Définit le modèle utilisé par la liste. Ce model peut ètre hierarchique sans limitation de la profondeur ou une chargé en asynchrone par une promise ou un observable.
     * @param items Provider de la liste des éléments de la liste.
     */
    public setItems$(items: any[] | Promise&lt;any[]&gt; | Observable&lt;any[]&gt;) {
        if (!items) {
            this.items &#x3D; undefined;
            return observableOf(null);
        } else if (items instanceof Array) {
            this.ensureChildrenProperties(items);
            this.ensureSelectedItems(items);
            this.items &#x3D; items;
            this._waiter$.next(false);
            return observableOf(items);
        } else {
            this.items &#x3D; undefined;
            this._waiter$.next(true);
            let observable &#x3D; items as Observable&lt;IItemBase[]&gt;;
            if (observable.subscribe &#x3D;&#x3D;&#x3D; undefined) {
                const promise &#x3D; items as Promise&lt;IItemBase[]&gt;;
                observable &#x3D; observableFrom(promise);
            }

            return observable.pipe(
                map((its) &#x3D;&gt; {
                    if (its) {
                        this.ensureChildrenProperties(its);
                        // TODO La déselection ne fonctionne pas pendant le chargement
                        this.ensureSelectedItems(its);
                        this.items &#x3D; [...this.items || [], ...its];
                        this._waiter$.next(false);
                        return its;
                    } else {
                        this.items &#x3D; [];
                        this._waiter$.next(false);
                        return [];
                    }
                }));
        }
    }

    public setModels$(items: any[] | Promise&lt;any[]&gt; | Observable&lt;any[]&gt;) {
        return this.setItems$(items);
    }

    /** Renvoie le modèle de grouping ajouté à la liste de base par le service. Ce modèle ne modifie pas la donée, mais est jsute ajouté à l&#x27;affichage
     * @return value Modèle de grouping d&#x27;affichage de la liste.
     */
    public get groupInfos() {
        return this._groupInfos;
    }

    // Ne pas utiliser, cette fonction retourne la liste des éléments pour l&#x27;implémentation de ngModel.
    public getItems() {
        return this.items;
    }

    /** Retourne l&#x27;élément corresondant à l&#x27;index spéficié dans la liste des éléments visibles.
     * @param index Index de l&#x27;élément à chercher sur la liste des éléments visibles.
     * @return Element correspondant à l&#x27;index recherché.
     */
    public getItemFromIndex(index: number) {
        return this._cache.visibleList ? this._cache.visibleList[index] : null;
    }

    /** Retourne l&#x27;index correspondant à l&#x27;élément spéficié dans la liste des éléments visibles
     * @param item Element à chercher sur la liste des éléments visibles.
     * @return Index correspondant à l&#x27;élément recherché.
     */
    public getItemIndex(item: IItemBase) {
        return this._cache.visibleList ? this._cache.visibleList.findIndex((itm) &#x3D;&gt; this.compareItems(item, itm)) : -1;
    }

    /** Renvoie le service utilisé pour le tri de la liste
     * @return Service utilisé pour le tri.
     */
    public getSortingService() {
        if (!this._sortingService) {
            this._sortingService &#x3D; new SortingService();
        }
        return this._sortingService;
    }

    /** Définit le service utilisé pour le tri de la liste
     * @param value  Service à utiliser pour le tri.
     */
    public setSortingService(value: SortingService) {
        this._sortingService &#x3D; value;
    }

    /** Renvoie le service utilisé pour le regroupement de la liste
     * @return Service utilisé pour le regroupement.
     */
    public getGroupingService() {
        if (!this._groupingService) {
            this._groupingService &#x3D; new GroupingService();
        }
        return this._groupingService;
    }

    /** Définit le service utilisé pour le regroupement de la liste
     * @param value Service à utiliser pour le regroupement.
     */
    public setGroupingService(value: GroupingService) {
        this._groupingService &#x3D; value;
    }

    /** Evalue le texte à afficher pour l&#x27;élément spécifié.
     * @param value  Model à évaluer.
     * @param textField (optional) Champs à traiter comme source du texte.
     * @return Texte à afficher pour le modèle spécifié.
     */
    public getTextValue(value: any, textField?: string) {
        return ItemListService.getItemText(value, textField);
    }

    /** Evalue la valeur à comparer pour l&#x27;élément spécifié.
     * @param value  Model à évaluer.
     * @param valueField (optional) Champs à traiter comme valeur.
     * @return Valeur à comparer pour le modèle spécifié.
     */
    public getValue(item: any, valueField?: string) {
        return ItemListService.getItemValue(item, valueField);
    }

    /** Usage interne. Termine le drag and drop en cours. */
    public drop$(): Observable&lt;boolean&gt; {
        return new Observable&lt;boolean&gt;((subscriber: Subscriber&lt;boolean&gt;) &#x3D;&gt; {
            if (!this._ddList || !this.items) {
                subscriber.next(false);
                return undefined;
            }

            const listIndex &#x3D; this._ddCurrentIndex;
            const item &#x3D; this._ddList[listIndex] as IItemTree;
            if (!item) {
                throw new Error(&#x27;invalid drag infos stored in cache.&#x27;);
            }

            // La drag and drop liste est incomplète, en cas de filtrage, retrouver l&#x27;élément juste en dessus dans la liste complète
            const targetItem &#x3D; this._ddList[listIndex - 1] as IItemTree;
            let targetParent: IItemTree;

            // Find target in the flat list to calculate the correct index
            let flatListIndex &#x3D; this._cache.flatList.findIndex((itm) &#x3D;&gt; itm &#x3D;&#x3D;&#x3D; targetItem);
            let targetIndex &#x3D; 0;
            while (flatListIndex &gt;&#x3D; 0) {
                const parentItem &#x3D; this._cache.flatList[flatListIndex] as IItemTree;
                if (parentItem.depth &#x3D;&#x3D;&#x3D; undefined) {
                    // Flat list
                    targetIndex &#x3D; flatListIndex;
                    break;
                } else if (parentItem.depth &#x3D;&#x3D;&#x3D; item.depth - 1) {
                    targetParent &#x3D; parentItem;
                    break;
                } else if (parentItem.depth &#x3D;&#x3D;&#x3D; item.depth) {
                    ++targetIndex;
                }
                --flatListIndex;
            }

            const findItem &#x3D; (itemToFind: IItemTree, treeList: IItemTree[]): IFindItemsResult &#x3D;&gt; {
                for (let i &#x3D; 0; i &lt; treeList.length; i++) {
                    const itm &#x3D; treeList[i];
                    if (itm &#x3D;&#x3D;&#x3D; itemToFind) {
                        return {
                            index: i,
                            list: treeList,
                        };
                    } else if (itm.$items !&#x3D;&#x3D; undefined) {
                        const result &#x3D; findItem(itemToFind, itm.$items);
                        if (result) {
                            return result;
                        }
                    }
                }
            };

            const originResult &#x3D; findItem(item, this.items);

            // Remove item from the origin
            originResult.list.splice(originResult.index, 1);

            // Add in the new location
            const targetList &#x3D; targetParent ? targetParent.$items : this.items;

            if (targetIndex &gt; originResult.index &amp;&amp; originResult.list &#x3D;&#x3D;&#x3D; targetList) {
                --targetIndex;
            }

            targetList.splice(targetIndex, 0, item);

            // Invalidate view cache
            this.invalidateCache();
            subscriber.next(true);
        });
    }

    /** Usage interne. Calcul l&#x27;élément cible d&#x27;un drag and drop en fonction de l&#x27;index spécifié. */
    public calcDragTargetIndex$(index: number, targetIndex: number): Observable&lt;number&gt; {
        return new Observable&lt;number&gt;((subscriber: Subscriber&lt;number&gt;) &#x3D;&gt; {
            const currentList &#x3D; this._ddList || this._cache.visibleList;

            if (!currentList) {
                throw new Error(&#x27;Empty cache on calcDragTargetIndex&#x27;);
            }

            const startIndex &#x3D; this._ddCurrentIndex !&#x3D;&#x3D; undefined ? this._ddCurrentIndex : index;
            if (startIndex &gt;&#x3D; currentList.length) {
                subscriber.next(currentList.length - 1);
                return undefined;
            }

            const item &#x3D; currentList[startIndex] as IItemTree;
            const dragDropIndex &#x3D; startIndex;

            if (item.depth !&#x3D;&#x3D; undefined &amp;&amp; targetIndex !&#x3D;&#x3D; startIndex) {
                if (targetIndex &lt; startIndex) {
                    // Remonte jusqu&#x27;au premier élément avec une profondeur plus grande
                    let beforeIndex &#x3D; 0;
                    for (let b &#x3D; startIndex - 1; b &gt;&#x3D; 0; b--) {
                        const targetItem &#x3D; currentList[b] as IItemTree;
                        if (targetItem.depth &lt;&#x3D; item.depth) {
                            beforeIndex &#x3D; b;
                            break;
                        }
                    }
                    if (targetIndex &lt;&#x3D; beforeIndex) {
                        // Descend jusqu&#x27;au premier élément avec la même profondeur
                        for (let a &#x3D; targetIndex; a &lt;&#x3D; beforeIndex; a++) {
                            const targetItem &#x3D; currentList[a] as IItemTree;
                            if (targetItem.depth &#x3D;&#x3D;&#x3D; item.depth) {
                                subscriber.next(a);
                                return undefined;
                            } else if (targetItem.depth &#x3D;&#x3D;&#x3D; item.depth - 1) {
                                subscriber.next(a + 1);
                                return undefined;
                            }
                        }
                    }
                }

                if (targetIndex &gt; startIndex) {
                    // Descend jusqu&#x27;au premier élément avec une profondeur plus grande ou égale
                    let afterIndex &#x3D; currentList.length - 1;
                    for (let a &#x3D; startIndex + 1; a &lt; currentList.length; a++) {
                        const targetItem &#x3D; currentList[a] as IItemTree;
                        if (targetItem.depth &lt;&#x3D; item.depth) {
                            afterIndex &#x3D; a;
                            break;
                        }
                    }
                    if (targetIndex &gt;&#x3D; afterIndex) {
                        // Descend jusqu&#x27;au premier élément avec la même profondeur
                        for (let a &#x3D; targetIndex + 1; a &lt; currentList.length; a++) {
                            const itm &#x3D; currentList[a] as IItemTree;
                            if (itm.depth &#x3D;&#x3D;&#x3D; item.depth) {
                                subscriber.next(a);
                                return undefined;
                            } else if (itm.depth &#x3D;&#x3D;&#x3D; item.depth - 1) {
                                subscriber.next(a - 1);
                                return undefined;
                            }
                        }
                        // Not found
                        const targetItem &#x3D; currentList[afterIndex] as IItemTree;
                        if (targetItem.depth &#x3D;&#x3D;&#x3D; item.depth) {
                            subscriber.next(afterIndex);
                            return undefined;
                        }
                    }
                }
            }

            subscriber.next(dragDropIndex);
        });
    }

    /** Change l&#x27;état d&#x27;expansion de tous les éléments.
     * @param collapsed True si les éléments doivent être réduits.
     * @return Observable résolu par la fonction.
     */
    public toggleAll$(collapsed: boolean): Observable&lt;IItemTree[]&gt; {
        return observableOf(this._cache.flatList).pipe(
            map((items: IItemTree[]) &#x3D;&gt; items.filter((item) &#x3D;&gt; item.$items &amp;&amp; item.collapsible !&#x3D;&#x3D; false)),
            tap(() &#x3D;&gt; delete this._cache.visibleList), // Invalidate view cache
            switchMap((items) &#x3D;&gt; collapsed ? this.collapseItems$(items) : this.expandItems$(items)));
    }

    /** Change l&#x27;état d&#x27;expansion de l&#x27;élément spécifié par son index sur la liste des éléments visibles.
     * @param index Index sur la liste des éléments visibles de l&#x27;élément à changer.
     * @param collapse Etat de l&#x27;élément. True pour réduire l&#x27;élément.
     * @return Observable résolu par la fonction.
     */
    public toggleCollapse$(index: number, collapse?: boolean): Observable&lt;IItemTree&gt; {
        const visibleList &#x3D; this._cache.visibleList;
        if (!visibleList || !visibleList.length) {
            throw new Error(&#x27;Empty cache on toggleCollapse&#x27;);
        }

        const item &#x3D; visibleList[index] as IItemTree;
        if (!item || item.collapsible &#x3D;&#x3D;&#x3D; false) {
            return observableOf([]);
        }

        const collapsed &#x3D; collapse !&#x3D;&#x3D; undefined ? collapse : item.collapsed ? false : true;
        return collapsed ? this.collapseItem$(item) : this.expandItem$(item);
    }

    /** Etends les éléments spécifiés.
     * @param items Liste des éléments à étendre.
     * @return Observable résolu par la fonction.
     */
    public expandItems$(items: IItemBase[]): Observable&lt;IItemBase[]&gt; {
        return observableFrom(items || []).pipe(
            switchMap((item) &#x3D;&gt; this.expandItem$(item)),
            reduce((acc, cur) &#x3D;&gt; [...acc, cur], []));
    }

    /** Reduits les éléments spécifiés.
     * @param items Liste des éléments à réduire.
     * @return Observable résolu par la fonction.
     */
    public collapseItems$(items: IItemBase[]): Observable&lt;IItemBase[]&gt; {
        return observableFrom(items || []).pipe(
            switchMap((item) &#x3D;&gt; this.collapseItem$(item)),
            reduce((acc, cur) &#x3D;&gt; [...acc, cur], []));
    }

    /** Etends l&#x27;élément spécifié.
     * @param items Eléments à étendre.
     * @return Observable résolu par la fonction.
     */
    public expandItem$(item: IItemTree) {
        return observableOf(item).pipe(
            filter((itm) &#x3D;&gt; !!itm),
            switchMap((itm) &#x3D;&gt; this.expandingItem$ ? this.expandingItem$(itm) : observableOf(itm)),
            filter((itm) &#x3D;&gt; !!itm),
            tap((itm) &#x3D;&gt; {
                itm.collapsed &#x3D; false;
                // Invalidate view cache
                delete this._cache.visibleList;
            }));
    }

    /** Réduit l&#x27;élément spécifié.
     * @param items Eléments à réduire.
     * @return Observable résolu par la fonction.
     */
    public collapseItem$(item: IItemTree) {
        return observableOf(item).pipe(
            filter((itm) &#x3D;&gt; !!itm),
            switchMap((itm) &#x3D;&gt; this.collapsingItem$ ? this.collapsingItem$(itm) : observableOf(itm)),
            filter((itm) &#x3D;&gt; !!itm),
            tap((itm) &#x3D;&gt; {
                itm.collapsed &#x3D; true;
                // Invalidate view cache
                delete this._cache.visibleList;
            }));
    }

    /** Retourne la liste des éléments sélectionés.
     * @return Liste des éléments selectionés.
     */
    public getSelectedItems() {
        return this.selectedList || [];
    }

    /** Définit la liste des éléments sélectionés.
     * @param items Liste des éléments a selectioner.
     */
    public setSelectedItems(items: IItemBase[]) {
        if (this.selectedList) {
            this.selectedList.forEach((item) &#x3D;&gt; {
                item.selected &#x3D; false;
            });
        }
        this.selectedList &#x3D; items;
        if (this.hideSelected) {
            delete this._cache.visibleList;
        }

        this.ensureSelectedItems(this.items);
    }

    /** Déselectionne tous les éléments sélectionés.
     * @return Observable résolu par la fonction.
     */
    public unselectAll$(): Observable&lt;IItemBase[]&gt; {
        if (this.hideSelected) {
            delete this._cache.visibleList;
        }

        const selectedList &#x3D; this.selectedList;
        this.selectedList &#x3D; [];

        return this.unSelectItems$(selectedList);
    }

    /** Sélectionne une plage d&#x27;éléments en fonction de l&#x27;index de début et l&#x27;index de fin sur la liste des éléments visibles.
     * @param indexFrom index sur la liste des éléments visibles du premier élément à sélectioner.
     * @param indexTo index sur la liste des éléments visibles du dernier élément à sélectioner.
     * @return Observable résolu par la fonction.
     */
    public selectRange$(indexFrom: number, indexTo?: number): Observable&lt;number&gt; {
        if (indexTo &#x3D;&#x3D;&#x3D; undefined) {
            indexTo &#x3D; indexFrom;
        }

        // Backup current visible list in case of unselectAll clear the cache
        const visibleList &#x3D; this._cache.visibleList;
        if (!visibleList || !visibleList.length) {
            throw new Error(&#x27;Empty cache on selection&#x27;);
        }

        return this.unselectAll$().pipe(
            map(() &#x3D;&gt; visibleList.slice(Math.min(indexFrom, indexTo), 1 + Math.max(indexFrom, indexTo))),
            map((items) &#x3D;&gt; items.filter((itm) &#x3D;&gt; itm.selectable !&#x3D;&#x3D; false)),
            tap(() &#x3D;&gt; {
                if (this.hideSelected) {
                    delete this._cache.visibleList;
                }
            }),
            switchMap((items) &#x3D;&gt; this.selectItems$(items).pipe(map((selected) &#x3D;&gt; selected.length))));
    }

    /** Change l&#x27;état de selection de l&#x27;élément spécifié.
     * @param items Liste des éléments à modifier.
     * @param selected True si les éléments divent être sélectionés, False si ils doivent être déselectionés.
     * @return Observable résolu par la fonction.
     */
    public toggleSelect$(items: IItemBase[], selected: boolean) {
        items &#x3D; items || [];
        return observableIif(() &#x3D;&gt; selected, this.selectItems$(items), this.unSelectItems$(items)).pipe(
            map(() &#x3D;&gt; {
                if (this.hideSelected) {
                    delete this._cache.visibleList;
                }
                return this.selectedList;
            }));
    }

    /** Sélectionne les éléments spécifiés
     * @param items Liste des éléments à sélectioner.
     * @return Observable résolu par la fonction.
     */
    public selectItems$(items: IItemBase[]): Observable&lt;IItemBase[]&gt; {
        return observableFrom(items || []).pipe(
            switchMap((item) &#x3D;&gt; this.selectItem$(item)),
            reduce((acc: IItemBase[], cur: IItemBase) &#x3D;&gt; [...acc, cur], []));
    }

    /** Déselectionne les éléments spécifiés
     * @param items Liste des éléments à déselectioner.
     * @return Observable résolu par la fonction.
     */
    public unSelectItems$(items: IItemBase[]): Observable&lt;IItemBase[]&gt; {
        return observableFrom(items || []).pipe(
            filter((item) &#x3D;&gt; item.selected),
            switchMap((item) &#x3D;&gt; this.unSelectItem$(item)),
            reduce((acc: IItemBase[], cur: IItemBase) &#x3D;&gt; [...acc, cur], []));
    }

    /** Sélectionne l&#x27;élément spécifié
     * @param item Elément à sélectioner.
     * @return Observable résolu par la fonction.
     */
    public selectItem$(item: IItemBase) {
        return observableOf(item).pipe(
            filter((itm) &#x3D;&gt; !!itm),
            switchMap((itm) &#x3D;&gt; this.selectingItem$ ? this.selectingItem$(itm) : observableOf(itm)),
            filter((itm) &#x3D;&gt; !!itm),
            tap((itm) &#x3D;&gt; {
                if (!this.selectedList) {
                    this.selectedList &#x3D; [];
                }

                itm.selected &#x3D; true;
                this.selectedList.push(itm);
            }));
    }

    /** Déselectionne l&#x27;élément spécifié
     * @param item Elément à déselectioner.
     * @return Observable résolu par la fonction.
     */
    public unSelectItem$(item: IItemBase) {
        return observableOf(item).pipe(
            filter((itm) &#x3D;&gt; !!itm),
            switchMap((itm) &#x3D;&gt; this.unselectingItem$ ? this.unselectingItem$(itm) : observableOf(itm)),
            filter((itm) &#x3D;&gt; !!itm),
            tap((itm) &#x3D;&gt; {
                itm.selected &#x3D; false;
                if (this.selectedList &amp;&amp; this.selectedList.length) {
                    const index &#x3D; this.selectedList.findIndex((i) &#x3D;&gt; this.compareItems(i, itm));
                    if (index &gt;&#x3D; 0) {
                        this.selectedList.splice(index, 1);
                    }
                }
            }));
    }

    /** Trouve l&#x27;élément suivant répondant à la fonction de comparaison spécifiée.
     * @param compare Function de comparaison pour la recherche de l&#x27;élément.
     * @param startIndex Index de départ sur la liste des éléments visibles.
     * @return Observable résolu par la fonction.
     */
    public findNextMatch$(compare?: (item: IItemBase, index: number) &#x3D;&gt; boolean, startIndex?: number): Observable&lt;IFindItemResult&gt; {
        let result &#x3D; { index: -1 } as IFindItemResult;

        const list &#x3D; this._cache.visibleList;
        if (!list || !list.length) {
            throw new Error(&#x27;Empty cache on findNextMatch&#x27;);
        }

        if (list.length) {
            if (startIndex &lt; 0 || startIndex &gt;&#x3D; list.length) {
                startIndex &#x3D; -1;
            }
            let idx &#x3D; startIndex + 1;
            while (idx !&#x3D;&#x3D; startIndex) {
                const itm &#x3D; list[idx];
                if (compare(itm, idx)) {
                    result &#x3D; {
                        index: idx,
                        item: itm,
                    } as IFindItemResult;
                    break;
                }
                idx++;
                if (idx &gt;&#x3D; list.length) {
                    if (startIndex &#x3D;&#x3D;&#x3D; -1) {
                        break;
                    }
                    idx &#x3D; 0;
                }
            }
        }
        return observableOf(result);
    }

    /** Trie les éléments en fonction du modèle de tri spécifié
     * @param sortInfos Modèle de tri à appliquer.
     * @return Observable résolu par la fonction.
     */
    public sort$(sortInfos: ISortInfos) {
        if (!this.items) {
            throw new Error(&#x27;No Items&#x27;);
        }

        const sortTree$ &#x3D; this.getSortingService()
            .sortTree$(this._cache.groupedList, sortInfos, &#x27;$items&#x27;).pipe(
                tap((sortedList: IItemTree[]) &#x3D;&gt; {
                    this._cache.groupedList &#x3D; sortedList;
                    this.invalidateViewCache();
                }));

        if (!this._cache.groupedList || this._cache.groupedList.length &#x3D;&#x3D;&#x3D; 0) {
            return this.getGroupedList$(this.items).pipe(
                tap((groupedList) &#x3D;&gt; this._cache.groupedList &#x3D; groupedList),
                switchMap(() &#x3D;&gt; sortTree$));
        } else {
            return sortTree$;
        }
    }

    /** Groupe les éléments en fonction du modèle de groupe spécifié
     * @param groupInfos Modèle de groupe à appliquer.
     * @return Observable résolu par la fonction.
     */
    public group$(groupInfos: IGroupInfo[]) {
        this._groupInfos &#x3D; groupInfos;
        this.invalidateCache();
        this.ensureChildrenProperties(this.items);
        return observableOf(groupInfos);
    }

    /** Retire les groupe correspondants au modèle de groupe spécifié
     * @param groupInfos Modèle de groupe à retirer.
     * @return Observable résolu par la fonction.
     */
    public ungroup$(groupInfo: IGroupInfo) {
        const groupIndex &#x3D; this._groupInfos ? this._groupInfos.findIndex((gi) &#x3D;&gt; gi.groupByField &#x3D;&#x3D;&#x3D; groupInfo.groupByField) : -1;
        if (groupIndex &gt;&#x3D; 0) {
            this._groupInfos.splice(groupIndex, 1);
        }

        this.invalidateCache();
        this.ensureChildrenProperties(this.items);
        return observableOf(groupInfo);
    }

    /** Retrouve les informations du parent de l&#x27;élément spécifié
     * @param item Element enfant du parent à retrouver.
     * @return Observable résolu par la fonction, qui retourne les informations sur le parent de l&#x27;élément spécifié
     */
    public getParentListInfos$(item: IItemTree, multiSelect: boolean): Observable&lt;IParentListInfoResult&gt; {
        const search$ &#x3D; (flatList: IItemBase[]) &#x3D;&gt; {
            let flatIndex &#x3D; flatList.findIndex((itm) &#x3D;&gt; itm &#x3D;&#x3D;&#x3D; item);
            if (flatIndex &lt; 0) {
                throw new Error(&#x27;Item not found.&#x27;);
            }

            let result: IParentListInfoResult;
            if (!item.depth) {
                const rootIndex &#x3D; this.items.findIndex((itm) &#x3D;&gt; itm &#x3D;&#x3D;&#x3D; item);
                result &#x3D; {
                    index: rootIndex,
                } as IParentListInfoResult;
            } else {
                // Search parent and treeindex
                let idx &#x3D; 0;
                while (--flatIndex &gt;&#x3D; 0) {
                    const parentItem &#x3D; flatList[flatIndex] as IItemTree;
                    if (parentItem.depth &lt; item.depth) {
                        result &#x3D; {
                            index: idx,
                            parent: parentItem,
                        } as IParentListInfoResult;
                    }
                    idx++;
                }
            }

            return observableOf(result);
        };

        return this.ensureFlatListCache$(true, multiSelect).pipe(
            switchMap(search$));
    }

    /** Supprime tous les caches internes. Ils seront recréés à la première demande de la portion de la liste à afficher. */
    public invalidateCache() {
        this._cache &#x3D; {};
        this.ensureChildrenProperties(this.items);
    }

    /** Efface la hauteur calculée des lignes en mode automatique */
    public invalidateRowsHeightCache() {
        if (this._items) {
            this._items.forEach((item) &#x3D;&gt; item.size &#x3D; undefined);
        }
    }

    /** Usage interne. Retourne la portion de la liste à afficher en fonction des paramètres spécifiés. */
    public getViewList$(searchField: string, query?: RegExp | string, ignoreCache?: boolean, ddStartIndex?: number, ddTargetIndex?: number, multiSelect?: boolean): Observable&lt;IViewListResult&gt; {
        const result &#x3D; {} as IViewListResult;

        const queryChanged &#x3D; (query &amp;&amp; query.toString()) !&#x3D;&#x3D; (this._lastQuery &amp;&amp; this._lastQuery.toString());
        ignoreCache &#x3D; ignoreCache || queryChanged || !this.items || !this.items.length;
        this._lastQuery &#x3D; query;

        const escapeChars &#x3D; (text: string) &#x3D;&gt; {
            const specialChars &#x3D; [&#x27;\\&#x27;, &#x27;/&#x27;, &#x27;|&#x27;, &#x27;&amp;&#x27;, &#x27;;&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;@&#x27;, &#x27;&quot;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;+&#x27;];
            specialChars.forEach((c) &#x3D;&gt; text &#x3D; text.replace(c, &#x60;\\${c}&#x60;));
            return text;
        };

        // Check regexp validity
        // regExp.test(this.getTextValue(item));
        let regExp: RegExp;
        if (query) {
            if (typeof query &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
                try {
                    query &#x3D; Diacritics.remove(query);
                    const escapedQuery &#x3D; escapeChars(query);
                    regExp &#x3D; new RegExp(escapedQuery, &#x27;i&#x27;);
                } catch (exc) {
                    console.log(&#x27;Invalid search parameters&#x27;);
                }
            } else {
                regExp &#x3D; query as RegExp;
                if (regExp.test &#x3D;&#x3D;&#x3D; undefined) {
                    regExp &#x3D; undefined;
                }
            }
        }

        const loadViewList &#x3D; () &#x3D;&gt; {
            let viewList: IItemBase[];
            if (ddStartIndex !&#x3D;&#x3D; undefined &amp;&amp; ddTargetIndex !&#x3D;&#x3D; undefined &amp;&amp; ddStartIndex !&#x3D;&#x3D; ddTargetIndex) {
                if (!this._ddList) {
                    // Generate a modified flat list for drag and drop Only
                    this._ddList &#x3D; [...this._cache.visibleList];

                    // Calc child count to be dragged
                    const draggedItem &#x3D; this._ddList[ddStartIndex] as IItemTree;
                    const parentDepth &#x3D; draggedItem.depth;
                    let lastIndex &#x3D; ddStartIndex;
                    if (parentDepth !&#x3D;&#x3D; undefined) {
                        for (let i &#x3D; ddStartIndex + 1; i &lt; this._ddList.length; i++) {
                            const curItem &#x3D; this._ddList[i] as IItemTree;
                            if (curItem.depth &lt;&#x3D; parentDepth) {
                                break;
                            }
                            lastIndex &#x3D; i;
                        }
                    }
                    this._ddChildCount &#x3D; lastIndex - ddStartIndex + 1;
                    this._ddCurrentIndex &#x3D; ddStartIndex;
                }

                const removed &#x3D; this._ddList.splice(this._ddCurrentIndex, this._ddChildCount);
                if (ddTargetIndex &gt; this._ddCurrentIndex) {
                    ddTargetIndex -&#x3D; this._ddChildCount;
                    ++ddTargetIndex;
                }
                this._ddCurrentIndex &#x3D; ddTargetIndex;
                removed.forEach((itm) &#x3D;&gt; this._ddList.splice(ddTargetIndex++, 0, itm));
                viewList &#x3D; this._ddList;

            } else {
                delete this._ddList;
                delete this._ddCurrentIndex;
                delete this._ddChildCount;
                viewList &#x3D; this._cache.visibleList || [];
            }

            result.depthMax &#x3D; this._cache.depthMax;
            result.visibleList &#x3D; viewList;

            return result;
        };

        if (ignoreCache) {
            // console.log(&#x27;getItemList &#x27; + Date.now());
            this.waiter$.next(true);

            if (queryChanged || !this.items || !this.items.length) {
                this.internalQuery &#x3D; regExp;
            }

            return this.getItemList$(query, this.selectedList).pipe(
                tap((items) &#x3D;&gt; {
                    if (!this.items || !this.items.length) {
                        this.ensureSelectedItems(items);
                    }

                    if (items !&#x3D;&#x3D; this.items) {
                        // New item list, invalidate view cache
                        this.items &#x3D; items;
                        // Be cause a new array was returned by getItemList, the list is considered as already filtered (Lazy loading)
                        this.internalQuery &#x3D; undefined;
                        this.ensureChildrenProperties(items);
                    }

                    delete this._cache.visibleList;
                    this.waiter$.next(this.items &#x3D;&#x3D;&#x3D; undefined);
                }),
                switchMap(() &#x3D;&gt; this.ensureVisibleListCache$(searchField, this.internalQuery, queryChanged, multiSelect)),
                map(loadViewList));
        } else {
            return this.ensureVisibleListCache$(searchField, this.internalQuery, queryChanged, multiSelect).pipe(
                map(loadViewList));
        }
    }

    public ensureSelection() {
        return this.ensureSelectedItems(this.items);
    }

    /** Retourne la liste à utilise pour la création des caches. Surcharger cetee méthode pour fournir une liste de façon lazy.
     * En cas de surcharge, retourner une nouvelle instance de la liste originale pour que le service regénère ses caches.
     * @param query Texte ou regular expression par laquelle la liste doit être filtrée.
     * @param selectedItems Liste des éléments selectionés.
     * @return Observable résolu par la fonction, qui retourne la liste à utiliser.
     */
    protected getItemList$(query?: RegExp | string, selectedItems?: IItemBase[]): Observable&lt;IItemBase[]&gt; {
        return this.loadingItems$ ? this.loadingItems$(query, selectedItems) : observableOf(this.items);
    }

    /** Retourne une valeur indiquant si l&#x27;élément spécifié correspond aux critères de recherche spécifiés
     * @param item Elément à analyser.
     * @param searchField Nom du champ à utiliser pour la recherche. Le champ représenté peut-être une valeur ou une function.
     * @param regExp Expression de test sur le champs spécifié.
     * @return True si l&#x27;élément correspond aux critères de recherche.
     */
    protected itemMatch(item: IItemBase, searchField: string, regExp: RegExp) {
        const itmTree &#x3D; (item as IItemTree);
        if (itmTree.$items) {
            return true;
        }
        const field &#x3D; (&lt;any&gt;item)[searchField];
        const value &#x3D; typeof field &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? field() : (field ? field : this.getTextValue(item, searchField));
        return value &amp;&amp; regExp.test(Diacritics.remove(value));
    }

    /** Retourne une liste groupée si un modèle de groupe interne est spécifié.
     * En cas de surcharge, retourner une nouvelle instance de la liste originale pour que le service regénère ses caches.
     * @param items Liste des éléments à grouper.
     * @return Observable résolu par la fonction, qui retourne la liste groupés.
     */
    protected getGroupedList$(items: IItemBase[]): Observable&lt;IItemTree[]&gt; {
        return items ? this.getGroupingService().group$(this.items, this.groupInfos, &#x27;$items&#x27;) : observableOf([]);
    }

    /** Retourne la liste des éléments visibles. Si la liste des éléments est hièrarchique, cette fonction retourne une liste plate. Cette liste est utilisé pour calculer la portion de la liste à afficher.
     * En cas de surcharge, retourner une nouvelle instance de la liste originale pour que le service regénère ses caches.
     * @param items Liste des éléments à traiter.
     * @param searchField Nom du champ à utiliser pour la recherche. Le champ représenté peut-être une valeur ou une function.
     * @param regExp Expression de test à appliquer sur le champ de recherche.
     * @param Auto expand parents on search query.
     * @return Observable résolu par la fonction, qui retourne la liste visibles.
     */
    protected getVisibleList$(items: IItemBase[], searchField: string, regExp: RegExp, expandTree: boolean, multiSelect: boolean): Observable&lt;IItemBase[]&gt; {
        if (!items) {
            return observableOf([]);
        }

        let visibleList &#x3D; [] as IItemTree[];
        const selectedList &#x3D; [] as IItemBase[];
        let odd &#x3D; false;

        if (regExp) {
            // Recalc visible list and select list from the filter
            const getFilteredList &#x3D; (treeList: IItemBase[], depth: number, hidden: boolean) &#x3D;&gt; {
                let filteredItems: IItemBase[];
                if (treeList) {
                    treeList.forEach((itm) &#x3D;&gt; {
                        const itmTree &#x3D; (itm as IItemTree);
                        if (itmTree.$items) {
                            if (itmTree.visible !&#x3D;&#x3D; false &amp;&amp; this.itemMatch(itmTree, searchField, regExp)) {
                                odd &#x3D; false;
                                const filteredChildren &#x3D; getFilteredList(itmTree.$items, depth + 1, hidden);
                                if (filteredChildren) {
                                    if (itmTree.collapsed &amp;&amp; expandTree) {
                                        itmTree.collapsed &#x3D; false;
                                    }
                                    filteredItems &#x3D; !filteredItems ? (itmTree.collapsed ? [itmTree] : [itmTree, ...filteredChildren]) : (itmTree.collapsed ? [...filteredItems, itmTree] : [...filteredItems, itmTree, ...filteredChildren]);
                                    if (itmTree.selected) {
                                        selectedList.push(itmTree);
                                    }
                                }
                            }

                            // compare fn can be something like re.test(this.getTextValue(itm)
                        } else if (this.itemMatch(itm, searchField, regExp)) {
                            itmTree.depth &#x3D; depth;
                            if (!filteredItems) {
                                filteredItems &#x3D; [];
                            }
                            if (!hidden &amp;&amp; !(itm.visible &#x3D;&#x3D;&#x3D; false) &amp;&amp; !(itm.selected &amp;&amp; this.hideSelected)) {
                                // For style
                                itmTree.odd &#x3D; odd;
                                odd &#x3D; !odd;

                                filteredItems.push(itmTree);
                            }
                            if (itmTree.selected) {
                                selectedList.push(itmTree);
                            }
                        } else if (itmTree.selected) {
                            selectedList.push(itmTree);
                        }
                    });
                }

                return filteredItems;
            };

            visibleList &#x3D; getFilteredList(items || [], 0, false) || [];

        } else {
            // Get visible items list without filter
            const getVisibleListInternal &#x3D; (treeList: IItemTree[], depth: number, hidden: boolean) &#x3D;&gt; {
                if (treeList) {
                    treeList.forEach((item) &#x3D;&gt; {
                        if (!hidden &amp;&amp; !(item.visible &#x3D;&#x3D;&#x3D; false) &amp;&amp; !(item.selected &amp;&amp; this.hideSelected)) {
                            // For style
                            item.odd &#x3D; odd;
                            odd &#x3D; !odd;

                            // Add to visible list only the visible items (uncollapsed)
                            visibleList.push(item);
                        }

                        // Add to selected list only the visible items (uncollapsed) and selected
                        if (item.selected) {
                            selectedList.push(item);
                        }

                        // Recursive call
                        if (item.$items) {
                            odd &#x3D; false;
                            getVisibleListInternal(item.$items, depth + 1, hidden || item.collapsed || item.visible &#x3D;&#x3D;&#x3D; false);
                        }
                    });
                }
            };

            getVisibleListInternal(items, 0, false);
        }

        return observableOf(visibleList).pipe(
            tap(() &#x3D;&gt; {
                if (!multiSelect) {
                    this.selectedList &#x3D; selectedList;
                }
            }));
    }

    /** Retourne une liste plate depuis la liste originale sans hierarchie.
     * En cas de surcharge, retourner une nouvelle instance de la liste originale pour que le service regénère ses caches.
     * @param items Liste des éléments hierarchique.
     * @return Observable résolu par la fonction, qui retourne la liste hierarchique mise à plat.
     */
    protected getFlatList$(items: IItemBase[], isFiltered: boolean, multiSelect: boolean): Observable&lt;IItemBase[]&gt; {
        if (!items) {
            return observableOf([]);
        }

        const visibleList &#x3D; [] as IItemBase[];
        const selectedList &#x3D; [] as IItemBase[];
        let depthMax &#x3D; 0;
        let isTree &#x3D; false;
        let odd &#x3D; false;

        const flatList$: any &#x3D; (itms: IItemTree[], depth: number, hidden: boolean) &#x3D;&gt; {
            return observableFrom(itms || []).pipe(
                tap((item) &#x3D;&gt; {
                    if (depth &gt; depthMax) {
                        depthMax &#x3D; depth;
                    }

                    // Fill system properties
                    item.depth &#x3D; depth;

                    if (!hidden &amp;&amp; !(item.visible &#x3D;&#x3D;&#x3D; false) &amp;&amp; !(item.selected &amp;&amp; this.hideSelected)) {
                        // For style
                        item.odd &#x3D; odd;
                        odd &#x3D; !odd;

                        // Add to visible list only the visible items (uncollapsed)
                        visibleList.push(item);
                    }

                    // Add to selected list only the visible items (uncollapsed) and selected
                    if (item.selected) {
                        selectedList.push(item);
                    }
                }),
                switchMap((item) &#x3D;&gt; {
                    if (item.$items) {
                        isTree &#x3D; true;
                        odd &#x3D; false;
                        return observableConcat(observableOf(item), flatList$(item.$items, depth + 1, hidden || item.collapsed));
                    } else {
                        return observableOf(item);
                    }
                }));
        };

        return flatList$(items, 0, false).pipe(
            tap(() &#x3D;&gt; {
                if (!multiSelect) {
                    this.selectedList &#x3D; selectedList;
                }

                if (!isFiltered) {
                    this._cache.visibleList &#x3D; visibleList;
                }
                this._cache.depthMax &#x3D; isTree ? depthMax : 0;
            }),
            reduce((acc: any[], cur: IItemBase) &#x3D;&gt; {
                acc.push(cur);
                return acc;
            }, []));
    }

    /** Efface une partie des caches  */
    protected invalidateViewCache() {
        delete this._cache.flatList;
        delete this._cache.visibleList;
        delete this._cache.depthMax;
        this._cache.rowsCount &#x3D; 0;
    }

    private ensureSelectedItems(items: IItemBase[]) {
        if (this.selectedList &amp;&amp; this.selectedList.length &gt; 0) {
            // Ensure selected flag
            this.selectedList.forEach((item) &#x3D;&gt; item.selected &#x3D; true);

            if (!items) {
                return this.selectedList;
            }

            const newSelectedList &#x3D; [] as IItemBase[];
            const ensureSelectedChildren &#x3D; (children: IItemTree[]) &#x3D;&gt; {
                children.forEach((item) &#x3D;&gt; {
                    const selectedItem &#x3D; this.selectedList.find((selected) &#x3D;&gt; this.compareItems(selected, item));
                    if (selectedItem) {
                        selectedItem.selected &#x3D; false;
                        newSelectedList.push(item);
                    }
                    if (item.$items) {
                        ensureSelectedChildren(item.$items);
                    }
                });
            };

            ensureSelectedChildren(items);

            // Add not found selected items
            this.selectedList.filter((item) &#x3D;&gt; item.selected).forEach((item) &#x3D;&gt; newSelectedList.push(item));

            this.selectedList &#x3D; newSelectedList;

            // Ensure selected flag for the new items
            this.selectedList.forEach((item) &#x3D;&gt; item.selected &#x3D; true);

        } else {
            this.selectedList &#x3D; [];

            if (!items) {
                return this.selectedList;
            }

            const ensureSelectedChildren &#x3D; (children: IItemTree[]) &#x3D;&gt; {
                children.forEach((item) &#x3D;&gt; {
                    if (item.selected) {
                        this.selectedList.push(item);
                    }
                    if (item.$items) {
                        ensureSelectedChildren(item.$items);
                    }
                });
            };

            ensureSelectedChildren(items);
        }

        return this.selectedList;
    }

    private compareItems &#x3D; (item1: IItemBase, item2: IItemBase) &#x3D;&gt; {
        // tslint:disable-next-line:triple-equals
        const isDefined &#x3D; (value: any) &#x3D;&gt; value !&#x3D; undefined;

        if (!isDefined(item1) || !isDefined(item2)) {
            return false;
        } else if (isDefined(item1) &amp;&amp; !isDefined(item2)) {
            return false;
        } else if (!isDefined(item1) &amp;&amp; isDefined(item2)) {
            return false;
        } else {
            if (item1.equals) {
                return item1.equals(item2);
            } else if (item2.equals) {
                return item2.equals(item1);
            } else if (item1.model &amp;&amp; item1.model.equals) {
                return item1.model.equals(item2.model);
            } else if (item2.model &amp;&amp; item2.model.equals) {
                return item2.model.equals(item1.model);
            } else {
                return this.getValue(item1, this._valueField) &#x3D;&#x3D;&#x3D; this.getValue(item2, this._valueField);
            }
        }
    }

    private ensureVisibleListCache$(searchField: string, regExp: RegExp, expandTree: boolean, multiSelect: boolean) {
        if (this._cache.visibleList &amp;&amp; this._cache.visibleList.length) {
            return observableOf(this._cache.visibleList);
        } else {
            return this.ensureFlatListCache$(!!regExp, multiSelect).pipe(
                switchMap(() &#x3D;&gt; this.getVisibleList$(this._cache.groupedList, searchField, regExp, expandTree, multiSelect)),
                tap((visibleList) &#x3D;&gt; {
                    /* if (this._cache.visibleList &amp;&amp; this._cache.visibleList.length &amp;&amp; this._cache.visibleList !&#x3D;&#x3D; visibleList) {
                     // New visible list
                     // Nothing to do yet
                     }*/

                    this._cache.visibleList &#x3D; visibleList;
                    this._cache.rowsCount &#x3D; visibleList.length;
                }));
        }
    }

    private ensureFlatListCache$(isFiltered: boolean, multiSelect: boolean) {
        if (this._cache.flatList &amp;&amp; this._cache.flatList.length) {
            return observableOf(this._cache.flatList);
        } else {
            return this.ensureGroupedListCache$().pipe(
                switchMap(() &#x3D;&gt; this.getFlatList$(this._cache.groupedList, isFiltered, multiSelect)),
                tap((flatList) &#x3D;&gt; {
                    if (this._cache.flatList &amp;&amp; this._cache.flatList.length &amp;&amp; this._cache.flatList !&#x3D;&#x3D; flatList) {
                        // New flat list
                        delete this._cache.visibleList;
                        this._cache.rowsCount &#x3D; 0;

                        // Ensure depth max
                        this._cache.depthMax &#x3D; 0;
                        if (flatList) {
                            flatList.forEach((item: IItemTree) &#x3D;&gt; {
                                if (item.depth &amp;&amp; item.depth &gt; this._cache.depthMax) {
                                    this._cache.depthMax &#x3D; item.depth;
                                }
                            });
                        }
                    }
                    this._cache.flatList &#x3D; flatList;
                }));
        }
    }

    private ensureGroupedListCache$() {
        if (this._cache.groupedList &amp;&amp; this._cache.groupedList.length) {
            return observableOf(this._cache.groupedList);
        } else if (!this.groupInfos || this.groupInfos.length &#x3D;&#x3D;&#x3D; 0) {
            return observableOf(this.items).pipe(
                tap((items) &#x3D;&gt; this._cache.groupedList &#x3D; items));
        } else if (this.items) {
            return this.getGroupedList$(this.items).pipe(
                tap((groupedList) &#x3D;&gt; {
                    if (this._cache.groupedList &amp;&amp; this._cache.groupedList.length &amp;&amp; this._cache.groupedList !&#x3D;&#x3D; groupedList) {
                        // New grouped list
                        this.invalidateViewCache();
                    }
                    this._cache.groupedList &#x3D; groupedList;
                }));
        } else {
            return observableOf([]);
        }
    }

    private ensureChildrenProperties(items: IItemTree[]) {
        if (!items) {
            return;
        }

        items.forEach((item) &#x3D;&gt; {
            const field &#x3D; (&lt;any&gt;item)[this.childrenField];
            if (field) {
                item.$items &#x3D; field;
                this.ensureChildrenProperties(item.$items);
            }
        });
    }
}

/** Structure de retour de getViewList. */
export interface IViewListResult {
    depthMax?: number;
    visibleList?: IItemBase[];
}

/** Structure de retour de findNextMatch. */
export interface IFindItemResult {
    /** Elément trouvé. */
    item: IItemBase;
    /** Index de l&#x27;élément dans la liste des éléments visibles. */
    index: number;
}

/** Structure de retour de getParentListInfos. */
export interface IParentListInfoResult {
    /** Elément parent. */
    parent?: IItemTree;
    /** Index de l&#x27;élément enfant dans la liste des enfants du parent. */
    index: number;
}

interface IFindItemsResult {
    list: IItemBase[];
    index: number;
}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'IViewListResult.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <script src="../js/menu-wc.js"></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
